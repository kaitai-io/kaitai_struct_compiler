package io.kaitai.struct.languages

import io.kaitai.struct.datatype.DataType._
import io.kaitai.struct.datatype._
import io.kaitai.struct.exprlang.Ast
import io.kaitai.struct.exprlang.Ast.expr.IntNum
import io.kaitai.struct.format._
import io.kaitai.struct.languages.components._
import io.kaitai.struct.translators.GoTranslator
import io.kaitai.struct.{ClassTypeProvider, RuntimeConfig, Utils}

class GoCompiler(typeProvider: ClassTypeProvider, config: RuntimeConfig)
  extends LanguageCompiler(typeProvider, config)
    with SingleOutputFile
    with UpperCamelCaseClasses
    with ObjectOrientedLanguage
    with UniversalFooter
    with UniversalDoc
    with GoWrites
    with FetchInstances
    with AllocateIOLocalVar
    with GoReads {
  import GoCompiler._

  private var inSubIOWriteBackHandler = false

  private var inSwitchCaseHandler = false

  private var firstPos2InScopeHandler = true

  override val translator = new GoTranslator(out, typeProvider, importList, config)

  override def innerClasses = false

  override def headerComment = "Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT."

  override def universalFooter: Unit = {
    out.dec
    out.puts("}")
  }

  override def indent: String = "\t"
  override def outFileName(topClassName: String): String =
    s"${config.goPackage}/$topClassName.go"

  override def outImports(topClass: ClassSpec): String = {
    val imp = importList.toList
    imp.size match {
      case 0 => ""
      case 1 => "import \"" + imp.head + "\"\n"
      case _ =>
        "import (\n" +
        imp.map((x) => indent + "\"" + x + "\"").mkString("", "\n", "\n") +
        ")\n"
    }
  }

  override def fileHeader(topClassName: String): Unit = {
    outHeader.puts(s"// $headerComment")
    if (config.goPackage.nonEmpty) {
      outHeader.puts
      outHeader.puts(s"package ${config.goPackage}")
    }
    outHeader.puts

    importList.add("github.com/kaitai-io/kaitai_struct_go_runtime/kaitai")

    out.puts
  }

  override def classExtendMarks(name: List[String]): Unit = {
    name.foreach(x => out.puts(s"$x"))
  }

  override def classHeader(name: List[String]): Unit = {
    out.puts(s"type ${types2class(name)} struct {")
    out.inc
  }

  override def classFooter(name: List[String]): Unit = {
    // TODO(jchw): where should this attribute actually be generated at?
    typeProvider.nowClass.meta.endian match {
      case Some(_: CalcEndian) | Some(InheritedEndian) =>
        out.puts(s"${idToStr(EndianIdentifier)} int")
      case _ =>
    }
    universalFooter
  }

  override def classConstructorHeader(name: List[String], parentType: DataType, rootClassName: List[String], isHybrid: Boolean, params: List[ParamDefSpec]): Unit = {
    val paramsArg = params.map((p) =>
      s"${paramName(p.id)} ${kaitaiType2NativeType(p.dataType)}"
    ).mkString(", ")

    out.puts(s"func New${types2class(name)}(_io *kaitai.Stream, _parent ${kaitaiType2NativeType(parentType)}, _root *${type2class(rootClassName(0))}) *${types2class(name)} {")
    out.inc
    out.puts(s"if _io == nil {")
    out.inc
    out.puts(s"_io = ${if (kaitaiType2NativeType(parentType) == "*kaitai.Stream") "_parent" else "_parent._io"}")
    out.dec
    out.puts("}")
    out.puts(s"return &${types2class(name)}{")
    out.inc
    out.puts("_io: _io, _parent: _parent, _root: _root,")
    out.dec
    out.puts("}")
    universalFooter
  }

  override def classConstructorFooter: Unit = {}


  override def fetchInstancesHeader(): Unit = {
    out.puts
    out.puts(
      s"func (this *${types2class(typeProvider.nowClass.name)}) fetchInstances() (err error) {".stripMargin)
    out.inc

    translator.returnRes = None
  }

  override def fetchInstancesFooter(): Unit = {
    out.puts("return err")
    out.dec
    out.puts("}")
  }

  override def attrInvokeFetchInstances(baseExpr: Ast.expr, exprType: DataType, dataType: DataType): Unit = {
    val expr = expression(baseExpr)
    var tmpVarName = ""
    if (inSwitchCaseHandler && kaitaiType2NativeType(exprType) == "interface{}") {
      tmpVarName = translator.interfaceTypeOfSwitchCase(expr, kaitaiType2NativeType(dataType))
    }

    out.puts(s"err = ${if (tmpVarName == "") expr else tmpVarName }.fetchInstances()")
    translator.outAddErrCheck()
  }

  override def attrInvokeInstance(instName: InstanceIdentifier): Unit = {}

  override def runWriteCalc(): Unit = {
    out.puts
    out.puts(s"switch ${privateMemberName(EndianIdentifier)} {")
    out.puts("case 0:")
    out.inc
    out.puts("err = this.writebe()")
    out.dec
    out.puts("case 1:")
    out.inc
    out.puts("err = this.writele()")
    out.dec
    out.puts("default:")
    out.inc
    out.puts(s"err = ${GoCompiler.ksErrorName(UndecidedEndiannessError)}{}")
    out.dec
    out.puts("}")
  }

  override def writeHeader(endian: Option[FixedEndian], isEmpty: Boolean): Unit = {
    out.puts
    endian match {
      case None =>
        out.puts(
          s"func (this *${types2class(typeProvider.nowClass.name)}) Write() (err error) {"
        )
        out.inc
        out.puts("err = this.WriteSeq(this._io)")
        translator.returnRes = None
        translator.outAddErrCheck()
        out.puts("err = this.fetchInstances()")
        translator.returnRes = None
        translator.outAddErrCheck()
        out.puts("return this._io.WriteBackChildStreams()")
        out.dec
        out.puts("}")
        out.puts
        out.puts(
          s"func (this *${types2class(typeProvider.nowClass.name)}) WriteSeq(inputIO *$kstreamName) (err error) {"
        )
        out.inc
        out.puts(s"${privateMemberName(IoIdentifier)} = inputIO")
        typeProvider.nowClass.meta.endian match {
          case Some(_: CalcEndian) =>
            out.puts(s"${privateMemberName(EndianIdentifier)} = -1")
          case Some(InheritedEndian) =>
            out.puts(s"${privateMemberName(EndianIdentifier)} = " +
              s"${privateMemberName(ParentIdentifier)}." +
              s"${idToStr(EndianIdentifier)}")
          case _ =>
        }
        out.puts
        translator.returnRes = None
      case Some(e) =>
        out.puts
        out.puts(
          s"func (this *${types2class(typeProvider.nowClass.name)}) write${e.toSuffix}() (err error) {")
        out.inc
        translator.returnRes = None
    }
  }

  override def writeFooter(): Unit = {
    out.puts("return err")
    universalFooter
  }

  override def writeInstanceHeader(instName: InstanceIdentifier): Unit = {
    out.puts
    out.puts(s"func (this *${types2class(typeProvider.nowClass.name)}) Write${publicMemberName(instName)}() (err error) {")
    out.inc
    instanceClearWriteFlag(instName)

    translator.returnRes = None
  }

  override def writeInstanceFooter(): Unit = {
    out.puts("return nil")
    out.dec
    out.puts("}")
  }
  // override def attrWrite(attr: AttrLikeSpec, id: Identifier, defEndian: Option[Endianness]): Unit = ???

  override def checkHeader(): Unit = {
    out.puts
    out.puts(s"func (this *${types2class(typeProvider.nowClass.name)}) Check() error {")
    out.inc

    translator.returnRes = None
  }
  override def checkFooter(): Unit = {
    out.puts("return nil")
    out.dec
    out.puts("}")
  }

  override def checkInstanceHeader(instName: InstanceIdentifier): Unit = {
    out.puts
    out.puts(s"func (this *${types2class(typeProvider.nowClass.name)}) Check${publicMemberName(instName)}() (err error) {")
    out.inc

    translator.returnRes = None
  }

  override def checkInstanceFooter(): Unit = {
    out.puts("return nil")
    out.dec
    out.puts("}")
  }
  // override def attrCheck(attr: AttrLikeSpec, id: Identifier): Unit = ???

  override def condRepeatCommonHeader(id: Identifier, io: String, dataType: DataType): Unit = {
    out.puts(s"for i := 0; i < len(${privateMemberName(id)}); i++ {")
    out.inc
  }
  // override def condRepeatCommonFooter: Unit = {}

  override def exprIORemainingSize(io: String): String = {
    out.puts(s"size, err := $io.Size()")
    translator.outAddErrCheck()
    out.puts(s"pos, err := $io.Pos()")
    translator.outAddErrCheck()
    out.puts("size = size")
    out.puts("pos = pos")
    s"size - pos"
  }

  override def subIOWriteBackHeader(subIO: String, process: Option[ProcessExpr]): String = {
    val parentIoName = "parent"

    out.puts(s"$subIO.SetWriteBackHandler(kaitai.NewWriteBackHandler(pos2, func($parentIoName *$kstreamName) error {")
    inSubIOWriteBackHandler = true
    out.inc
    translator.returnRes = None
    parentIoName
  }

  override def subIOWriteBackSetter(subIO: String): Unit = {
    out.puts(s"$subIO.SetWriteBackHandler(NewSubIO())")
  }

  override def subIOWriteBackFooter(subIO: String): Unit = {
    inSubIOWriteBackHandler = false
    out.puts("return err")
    out.dec
    out.puts("}))")
    out.puts
  }

  override def addChildIO(io: String, childIO: String): Unit = {
    out.puts(s"$io.AddChildStream($childIO)")
  }

  override def instanceWriteFlagDeclaration(attrName: InstanceIdentifier): Unit = {
    out.puts(s"_write${publicMemberName(attrName)} bool")
    out.puts(s"_toWrite${publicMemberName(attrName)} bool")
  }

  // override def instanceWriteFlagInit(attrName: InstanceIdentifier): Unit = {}
  override def instanceSetWriteFlag(instName: InstanceIdentifier): Unit = {
    out.puts(s"this._write${publicMemberName(instName)} = this._toWrite${publicMemberName(instName)}")
  }

  override def instanceClearWriteFlag(instName: InstanceIdentifier): Unit = {
    out.puts(s"this._write${publicMemberName(instName)} = false")
  }

  override def instanceToWriteSetter(instName: InstanceIdentifier): Unit = {
    out.puts(s"func (this *${types2class(typeProvider.nowClass.name)}) set${publicMemberName(instName)}ToWrite(_v bool) { this._toWrite${publicMemberName(instName)} = _v }")
  }

  override def instanceInvalidate(instName: InstanceIdentifier): Unit = {
    // go can not convert num to bool directly
    val actualNameAndType = instName.name.split("_insplit_")
    var instType = "0"
    if ( actualNameAndType.length == 2 ) {
      if (actualNameAndType(1).contains("bool")) {
        instType = "false"
      } else if ((actualNameAndType(1).contains("usertype") || actualNameAndType(1).contains("arraytype") || actualNameAndType(1).contains("bytestype")) && !actualNameAndType(1).contains("from")) {
        instType = "nil"
      } else if (actualNameAndType(1).contains("str")) {
        instType = "\"\""
      }
    }

    val actualInst = InstanceIdentifier(actualNameAndType(0))
    out.puts(s"func (this *${types2class(typeProvider.nowClass.name)}) Invalidate${publicMemberName(actualInst)}() { ${privateMemberName(actualInst)} = $instType; this.${calculatedFlagForName(actualInst)} = false; }")
  }

  override def instanceCheckWriteFlagAndWrite(instName: InstanceIdentifier): Unit = {
    out.puts(s"if this._write${publicMemberName(instName)} {")
    out.inc
    out.puts(s"err := this.Write${publicMemberName(instName)}()")
    translator.outAddErrCheck()
    out.dec
    out.puts("}")
  }

  override def runRead(name: List[String]): Unit = {
    out.puts("this.Read()")
  }

  override def runReadCalc(): Unit = {
    out.puts
    out.puts(s"switch ${privateMemberName(EndianIdentifier)} {")
    out.puts("case 0:")
    out.inc
    out.puts("err = this._read_be()")
    out.dec
    out.puts("case 1:")
    out.inc
    out.puts("err = this._read_le()")
    out.dec
    out.puts("default:")
    out.inc
    out.puts(s"err = ${GoCompiler.ksErrorName(UndecidedEndiannessError)}{}")
    out.dec
    out.puts("}")
  }

  override def readHeader(endian: Option[FixedEndian], isEmpty: Boolean): Unit = {
    endian match {
      case None =>
        out.puts
        out.puts(
          s"func (this *${types2class(typeProvider.nowClass.name)}) Read() (err error) {"
        )
        out.inc
        typeProvider.nowClass.meta.endian match {
          case Some(_: CalcEndian) =>
            out.puts(s"${privateMemberName(EndianIdentifier)} = -1")
          case Some(InheritedEndian) =>
            out.puts(s"${privateMemberName(EndianIdentifier)} = " +
              s"${privateMemberName(ParentIdentifier)}." +
              s"${idToStr(EndianIdentifier)}")
          case _ =>
        }
        out.puts
        translator.returnRes = None
      case Some(e) =>
        out.puts
        out.puts(
          s"func (this *${types2class(typeProvider.nowClass.name)}) " +
            s"_read_${e.toSuffix}() (err error) {")
        out.inc
        translator.returnRes = None
    }

  }
  override def readFooter: Unit = {
    out.puts("return err")
    universalFooter
  }

  override def attributeDeclaration(attrName: Identifier, attrType: DataType, isNullable: Boolean): Unit = {
    out.puts(s"${idToStr(attrName)} ${kaitaiType2NativeType(attrType)}")
    translator.returnRes = None
  }

  override def attributeReader(attrName: Identifier, attrType: DataType, isNullable: Boolean): Unit = {}
  override def attributeSetter(attrName: Identifier, attrType: DataType, isNullable: Boolean): Unit = {
    val goType = kaitaiType2NativeType(attrType)
    val name = idToStr(attrName)

    out.puts(s"func (this *${types2class(typeProvider.nowClass.name)}) Set${idToStr(attrName)}(_v $goType) *${types2class(typeProvider.nowClass.name)} { this.$name = _v; return this; }")
  }
  override def attrSetProperty(base: Ast.expr, propName: Identifier, value: String): Unit = {
    out.puts(s"${expression(base)}.${publicMemberName(propName)} = $value")
  }

  override def universalDoc(doc: DocSpec): Unit = {
    out.puts
    out.puts( "/**")

    doc.summary.foreach(summary => out.putsLines(" * ", summary))

    doc.ref.foreach {
      case TextRef(text) =>
        out.putsLines(" * ", "@see \"" + text + "\"")
      case ref: UrlRef =>
        out.putsLines(" * ", s"@see ${ref.toAhref}")
    }

    out.puts( " */")
  }

  override def attrParseHybrid(leProc: () => Unit, beProc: () => Unit): Unit = {
    out.puts(s"switch ${privateMemberName(EndianIdentifier)} {")
    out.puts("case 0:")
    out.inc
    beProc()
    out.dec
    out.puts("case 1:")
    out.inc
    leProc()
    out.dec
    out.puts("default:")
    out.inc
    out.puts(s"err = ${GoCompiler.ksErrorName(UndecidedEndiannessError)}{}")
    out.dec
    out.puts("}")
  }

  override def attrProcess(proc: ProcessExpr, varSrc: Identifier, varDest: Identifier, rep: RepeatSpec): Unit = {
    val srcExpr = getRawIdExpr(varSrc, rep)

    val expr = proc match {
      case ProcessXor(xorValue) =>
        translator.detectType(xorValue) match {
          case _: IntType =>
            s"kaitai.ProcessXOR($srcExpr, []byte{${expression(xorValue)}})"
          case _: BytesType =>
            s"kaitai.ProcessXOR($srcExpr, ${expression(xorValue)})"
        }
      case ProcessZlib =>
        translator.outVarCheckRes(s"kaitai.ProcessZlib($srcExpr)")
      case ProcessRotate(isLeft, rotValue) =>
        val expr = if (isLeft) {
          expression(rotValue)
        } else {
          s"8 - (${expression(rotValue)})"
        }
        s"kaitai.ProcessRotateLeft($srcExpr, int($expr))"
      case ProcessCustom(name, args) =>
        // TODO(jchw): This hack is necessary because Go tests fail catastrophically otherwise...
        s"$srcExpr"
    }
    handleAssignment(varDest, expr, rep, false)
  }

  override def allocateIO(varName: Identifier, rep: RepeatSpec): String = {
    val ioName = idToStr(IoStorageIdentifier(varName))
    val args = rep match {
      case RepeatUntil(_) => translator.specialName(Identifier.ITERATOR2)
      case _ => getRawIdExpr(varName, rep)
    }

    importList.add("github.com/kaitai-io/kaitai_struct_go_runtime/buffer")
    out.puts(s"$ioName := kaitai.NewStream(buffer.NewSeekableBufferWithBytes($args))")
    ioName
  }

  override def allocateIOFixed(varName: Identifier, size: String): String = {
    val ioName = idToStr(IoStorageIdentifier(varName))
    out.puts(s"$ioName := kaitai.NewStream(buffer.NewSeekableBufferWithBytes(make([]byte, $size)))")
    ioName
  }

  override def allocateIOGrowing(varName: Identifier): String =
    allocateIOFixed(varName, "100000")

  def getRawIdExpr(varName: Identifier, rep: RepeatSpec): String = {
    val memberName = privateMemberName(varName)
    rep match {
      case NoRepeat => memberName
      case RepeatExpr(_) => s"$memberName[i]"
      case _ => s"$memberName[len($memberName) - 1]"
    }
  }

  override def useIO(ioEx: Ast.expr): String = {
    out.puts(s"thisIo := ${expression(ioEx)}")
    "thisIo"
  }

  override def pushPos(io: String): Unit = {
    out.puts(s"_pos, err := $io.Pos()")
    translator.outAddErrCheck()
  }

  override def pushPosForSubIOWriteBackHandler(io: String): Unit = {
    importList.add("io")
    out.puts(s"pos2, err := $io.Pos()")
    translator.outAddErrCheck()
  }

  override def seek(io: String, pos: Ast.expr): Unit = {
    importList.add("io")

    out.puts(s"_, err = $io.Seek(int64(${expression(pos)}), io.SeekStart)")
    translator.outAddErrCheck()
  }

  override def seekRelative(io: String, relPos: String): Unit = {
    importList.add("io")
    out.puts(s"$io.Seek(int64($relPos), io.SeekCurrent)")
  }

  override def popPos(io: String): Unit = {
    importList.add("io")

    out.puts(s"_, err = $io.Seek(int64(_pos), io.SeekStart)")
    translator.outAddErrCheck()
  }

  override def alignToByte(io: String): Unit =
    out.puts(s"$io.AlignToByte()")

  override def condIfHeader(expr: Ast.expr): Unit = {
    out.puts(s"if ${expression(expr)} {")
    firstPos2InScopeHandler = true
    out.inc
  }

  override def condRepeatInitAttr(id: Identifier, dataType: DataType): Unit = {
    // slices don't have to be manually initialized in Go: the built-in append()
    // function works even on `nil` slices (https://go.dev/tour/moretypes/15)
    out.puts(s"${privateMemberName(id)} = make(${kaitaiType2NativeType(ArrayTypeInStream(dataType))}, 0)")
  }

  override def condRepeatEosHeader(id: Identifier, io: String, dataType: DataType): Unit = {
    out.puts(s"for i := 1;; i++ {")
    out.inc

    val eofVar = translator.allocateLocalVar()
    out.puts(s"${translator.localVarName(eofVar)}, err := this._io.EOF()")
    translator.outAddErrCheck()
    out.puts(s"if ${translator.localVarName(eofVar)} {")
    out.inc
    out.puts("break")
    out.dec
    out.puts("}")
  }

  override def handleAssignmentRepeatEos(id: Identifier, r: String): Unit = {
    val name = privateMemberName(id)
    val expr = r
    out.puts(s"$name = append($name, $expr)")
  }

  override def condRepeatExprHeader(id: Identifier, io: String, dataType: DataType, repeatExpr: Ast.expr): Unit = {
    out.puts(s"for i := 0; i < int(${expression(repeatExpr)}); i++ {")
    out.inc
    // FIXME: Go throws a fatal compile error when the `i` variable is not used (unused variables
    // can only use the blank identifier `_`, see https://go.dev/doc/effective_go#blank), so we have
    // to silence it like this. It would be nice to be able to analyze all expressions that appear
    // in the loop body to decide whether to generate `for _ := range` or `for i := range` here, but
    // that would be really difficult to do properly in KSC with the current architecture.
    out.puts("_ = i")
  }

  override def handleAssignmentRepeatExpr(id: Identifier, r: String): Unit =
    handleAssignmentRepeatEos(id, r)

  override def condRepeatUntilHeader(id: Identifier, io: String, dataType: DataType, untilExpr: Ast.expr): Unit = {
    out.puts(s"for i := 1;; i++ {")
    out.inc
  }

  override def handleAssignmentRepeatUntil(id: Identifier, r: String, isRaw: Boolean): Unit = {
    val expr = r
    val tempVar = translator.specialName(if (isRaw) Identifier.ITERATOR2 else Identifier.ITERATOR)
    out.puts(s"$tempVar := $expr")
    out.puts(s"${privateMemberName(id)} = append(${privateMemberName(id)}, $tempVar)")
  }

  override def condRepeatUntilFooter(id: Identifier, io: String, dataType: DataType, untilExpr: Ast.expr): Unit = {
    typeProvider._currentIteratorType = Some(dataType)
    out.puts(s"if ${expression(untilExpr)} {")
    out.inc
    out.puts("break")
    out.dec
    out.puts("}")
    out.dec
    out.puts("}")
  }

  private def castToType(r: String, dataType: DataType): String = {
    dataType match {
      case t @ (_: IntMultiType | _: FloatMultiType | CalcIntType | CalcFloatType) =>
        s"${kaitaiType2NativeType(t)}(${r})"
      case _ =>
        r
    }
  }

  private def combinedType(dataType: DataType) = {
    dataType match {
      case st: SwitchType => st.combinedType
      case _ => dataType
    }
  }

  def handleCompositeTypeCast(id: Identifier, r: String): String = {
    id match {
      case NamedIdentifier(name) =>
        castToType(r, combinedType(typeProvider.determineType(name)))
      case _ =>
        r
    }
  }

  override def handleAssignmentSimple(id: Identifier, r: String): Unit = {
    val expr = handleCompositeTypeCast(id, r)
    out.puts(s"${privateMemberName(id)}${if (translator.returnRes != None && translator.returnRes.get == "err") ", err" else "" } = $expr")
    if (translator.returnRes != None && translator.returnRes.get == "err") {
      translator.returnRes = None
      translator.outAddErrCheck()
    }
  }

  override def handleAssignmentTempVar(dataType: DataType, id: String, expr: String): Unit =
    out.puts(s"$id := $expr")

  def handleAssignmentError(id: Identifier, r: String): Unit = {
    val expr = handleCompositeTypeCast(id, r)
    out.puts(s"${privateMemberName(id)}, err = $expr")
    translator.outAddErrCheck()
  }

  override def blockScopeHeader: Unit = {
    out.puts("{")
    out.inc
  }
  override def blockScopeFooter: Unit = universalFooter

  override def parseExpr(dataType: DataType, io: String, defEndian: Option[FixedEndian]): String = {
    dataType match {
      case t: ReadableType =>
        s"$io.Read${Utils.capitalize(t.apiCall(defEndian))}()"
      case blt: BytesLimitType =>
        s"$io.ReadBytes(int(${expression(blt.size)}))"
      case _: BytesEosType =>
        s"$io.ReadBytesFull()"
      case BytesTerminatedType(terminator, include, consume, eosError, _) =>
        s"$io.ReadBytesTerm($terminator, $include, $consume, $eosError)"
      case BitsType1(bitEndian) =>
        s"$io.ReadBitsInt${Utils.upperCamelCase(bitEndian.toSuffix)}(1)"
      case BitsType(width: Int, bitEndian) =>
        s"$io.ReadBitsInt${Utils.upperCamelCase(bitEndian.toSuffix)}($width)"
      case t: UserType =>
        val addArgs = if (t.isOpaque) {
          ""
        } else {
          val parent = t.forcedParent match {
            case Some(USER_TYPE_NO_PARENT) => "nil"
            case Some(fp) => translator.translate(fp)
            case None => "this"
          }
          s", $parent, _root"
        }
        s"${types2class(t.name)}($io$addArgs)"
    }
  }

//  override def bytesPadTermExpr(expr0: String, padRight: Option[Int], terminator: Option[Int], include: Boolean) = {
//    val expr1 = padRight match {
//      case Some(padByte) => s"$kstreamName.bytesStripRight($expr0, (byte) $padByte)"
//      case None => expr0
//    }
//    val expr2 = terminator match {
//      case Some(term) => s"$kstreamName.bytesTerminate($expr1, (byte) $term, $include)"
//      case None => expr1
//    }
//    expr2
//  }

  override def switchStart(id: Identifier, on: Ast.expr): Unit = {
    out.puts(s"switch (${expression(on)}) {")
    inSwitchCaseHandler = true
  }

  override def switchCaseStart(condition: Ast.expr): Unit = {
    out.puts(s"case ${expression(condition)}:")
    out.inc

    inSwitchCaseHandler = true
  }

  override def switchCaseEnd(): Unit = {
    out.dec
    inSwitchCaseHandler = false
  }

  override def switchElseStart(): Unit = {
    out.puts("default:")
    out.inc

    inSwitchCaseHandler = true
  }

  override def switchEnd(): Unit = {
    out.puts("}")
    inSwitchCaseHandler = false
  }

  override def switchShouldUseCompareFn(onType: DataType): (Option[String], () => Unit) = {
    onType match {
      case _: BytesType =>
        (Some("bytes.Equal"), () => importList.add("bytes"))
      case _ =>
        (None, () => {})
    }
  }

  override def switchCaseStartCompareFn(compareFn: String, switchOn: Ast.expr, condition: Ast.expr): Unit = {
    out.puts(s"case ${compareFn}(${expression(switchOn)}, ${expression(condition)}):")
    out.inc

    inSwitchCaseHandler = true
  }

  override def instanceDeclaration(attrName: InstanceIdentifier, attrType: DataType, isNullable: Boolean): Unit = {
    out.puts(s"${calculatedFlagForName(attrName)} bool")
    out.puts(s"${idToStr(attrName)} ${kaitaiType2NativeType(attrType)}")
  }

  override def instanceHeader(className: List[String], instName: InstanceIdentifier, dataType: DataType, isNullable: Boolean): Unit = {
    out.puts(s"func (this *${types2class(className)}) ${publicMemberName(instName)}() (v ${kaitaiType2NativeType(dataType)}, err error) {")
    out.inc
    translator.returnRes = Some(dataType match {
      case _: NumericType => "0"
      case _: BooleanType => "false"
      case _: StrType => "\"\""
      case _ => "nil"
    })
  }

  override def instanceCalculate(instName: Identifier, dataType: DataType, value: Ast.expr): Unit = {
    val r = translator.translate(value)
    val rtype = translator.detectType(value)

    val converted = dataType match {
      case _: UserType => r
      case _ => s"${kaitaiType2NativeType(dataType)}($r)"
    }
    out.puts(s"${privateMemberName(instName)} = $converted")
  }

  override def instanceCheckCacheAndReturn(instName: InstanceIdentifier, dataType: DataType): Unit = {
    out.puts(s"if this.${calculatedFlagForName(instName)} {")
    out.inc
    instanceReturn(instName, dataType)
    firstPos2InScopeHandler = true
    universalFooter
  }

  override def instanceReturn(instName: InstanceIdentifier, attrType: DataType): Unit = {
    out.puts(s"return ${privateMemberName(instName)}, nil")
  }

  override def instanceSetCalculated(instName: InstanceIdentifier): Unit =
    out.puts(s"this.${calculatedFlagForName(instName)} = true")

  override def enumDeclaration(curClass: List[String], enumName: String, enumColl: Seq[(Long, EnumValueSpec)]): Unit = {
    val fullEnumName: List[String] = curClass ++ List(enumName)
    val fullEnumNameStr = types2class(fullEnumName)

    out.puts
    out.puts(s"type $fullEnumNameStr int")
    out.puts("const (")
    out.inc

    enumColl.foreach { case (id, label) =>
      out.puts(s"${enumToStr(fullEnumName, label.name)} $fullEnumNameStr = $id")
    }

    out.dec
    out.puts(")")
  }

  override def classToString(toStringExpr: Ast.expr): Unit = {
    out.puts
    out.puts(s"func (this ${types2class(typeProvider.nowClass.name)}) String() string {")
    out.inc
    out.puts(s"return ${translator.translate(toStringExpr)}")
    out.dec
    out.puts("}")
  }

  override def idToStr(id: Identifier): String = GoCompiler.idToStr(id)

  override def publicMemberName(id: Identifier): String = GoCompiler.publicMemberName(id)

  override def privateMemberName(id: Identifier): String = s"this.${idToStr(id)}"

  override def localTemporaryName(id: Identifier): String = s"_t_${idToStr(id)}"

  override def paramName(id: Identifier): String = Utils.lowerCamelCase(id.humanReadable)

  def calculatedFlagForName(id: Identifier) = s"_f_${idToStr(id)}"

  override def ksErrorName(err: KSError): String = GoCompiler.ksErrorName(err)

  override def attrValidateExpr(
    attr: AttrLikeSpec,
    checkExpr: Ast.expr,
    err: KSError,
    useIo: Boolean,
    expected: Option[Ast.expr] = None
  ): Unit = {
    val errArgsStr = expected.map(expression) ++ List(
      expression(Ast.expr.InternalName(attr.id)),
      if (useIo) expression(Ast.expr.InternalName(IoIdentifier)) else "nil",
      expression(Ast.expr.Str(attr.path.mkString("/", "/", "")))
    )
    out.puts(s"if !(${translator.translate(checkExpr)}) {")
    firstPos2InScopeHandler = true
    out.inc
    val errInst = s"kaitai.New${err.name}(${errArgsStr.mkString(", ")})"
    val noValueAndErr = translator.returnRes match {
      case None => errInst
      case Some(r) => {
        if (r == "nil") {
          errInst
        } else {
          s"$r, $errInst"
        }
      }
    }
    out.puts(s"return $noValueAndErr")
    out.dec
    out.puts("}")
  }

  override def internalEnumIntType(basedOn: IntType): DataType = {
    basedOn match {
      case IntMultiType(signed, _, endian) => IntMultiType(signed, Width8, endian)
      case _ => IntMultiType(signed = true, Width8, None)
    }
  }

  def castIfNeeded(exprRaw: String, exprType: DataType, targetType: DataType): String =
    if (exprRaw.contains(".(")) {
      return exprRaw
    } else {
      if (exprType != targetType || exprRaw.startsWith("(len")) {
        val castTypeId = kaitaiType2NativeType(targetType)
        targetType match {
          case _: NumericType => {
            val resType = exprType match {
              case AnyType => s"$exprRaw.($castTypeId)"
              case _ => s"$castTypeId($exprRaw)"
            }
            resType
          }
          case _: BytesType | _: BytesLimitType | _: BytesEosType => {
            if (exprRaw.contains("_raw_")) {
              return s"$exprRaw"
            }
            val resType = exprType match {
              case AnyType => s"$exprRaw.($castTypeId)"
              case _ => s"$exprRaw"
            }
            resType
          }
          // case _ : CalcUserType => s"${castTypeId.stripPrefix("*")}{ReadWriteStream: $exprRaw}"
          case _ => s"$exprRaw"
        }
      } else {
        exprRaw
      }
    }


  override def attrPrimitiveWrite(io: String, expr: Ast.expr, dt: DataType, defEndian: Option[FixedEndian], exprTypeOpt: Option[DataType]): Unit = {
    val exprType = exprTypeOpt.getOrElse(dt)
    val exprRaw = expression(expr)
    val exprProcessed = castIfNeeded(exprRaw, exprType, dt)

    val stmt = dt match {
      case t: ReadableType =>
        s"$io.Write${Utils.capitalize(t.apiCall(defEndian))}($exprProcessed)"
      case BitsType1(bitEndian) =>
        s"$io.WriteBitsInt${Utils.upperCamelCase(bitEndian.toSuffix)}(1, ${translator.boolToInt(expr)})"
      case BitsType(width: Int, bitEndian) =>
        s"$io.WriteBitsInt${Utils.upperCamelCase(bitEndian.toSuffix)}($width, $exprProcessed)"
      case _: BytesType =>
        s"$io.WriteBytes($exprProcessed)"
    }
    out.puts(s"err = $stmt")
  }

  override def attrBytesLimitWrite(io: String, expr: Ast.expr, size: String, term: Int, padRight: Int): Unit = {
    out.puts(s"$io.WriteBytesLimit(${expression(expr)}, $size, $term, $padRight)")
  }

  override def attrUserTypeInstreamWrite(io: String, valueExpr: Ast.expr, t: DataType, exprType: DataType): Unit = {
    val exprRaw = expression(valueExpr)
    val expr = castIfNeeded(exprRaw, exprType, t)

    var changedExpr = valueExpr
    var tmpVarName = ""
    if (inSwitchCaseHandler && kaitaiType2NativeType(translator.detectType(valueExpr)) == "interface{}") {
      val (changedActual, tmpName) = translator.interfaceTypeOfSwitchCaseInExpr(valueExpr, Option(t), (dt) => {
        kaitaiType2NativeType(dt)
      })
      changedExpr = changedActual
      tmpVarName = tmpName
    }

    if (tmpVarName != "") {
      tmpVarName = expression(valueExpr).replace(expression(changedExpr), tmpVarName)
    } else {
      tmpVarName = expression(valueExpr)
    }

    out.puts(s"err = $tmpVarName.WriteSeq($io)")
    translator.outAddErrCheck()
  }

  override def exprStreamToByteArray(ioFixed: String): String = {
    out.puts(s"fixedByteArray, err := $ioFixed.ToByteArray()")
    s"fixedByteArray"
  }

  override def attrUnprocess(proc: ProcessExpr, varSrc: Identifier, varDest: Identifier, rep: RepeatSpec, dt: BytesType, exprTypeOpt: Option[DataType]): Unit = {
    val exprType = exprTypeOpt.getOrElse(dt)
    val srcExprRaw = varSrc match {
      // use `_raw_items[_raw_items.size - 1]`
      case _: RawIdentifier => getRawIdExpr(varSrc, rep)
      // but `items[_index]`
      case _ => expression(itemExpr(varSrc, rep))
    }
    val srcExpr = castIfNeeded(srcExprRaw, exprType, dt)

    val expr = proc match {
      case ProcessXor(xorValue) =>
        val argStr = if (inSubIOWriteBackHandler) "processXorArg" else expression(xorValue)
        val xorValueStr = translator.detectType(xorValue) match {
          case _: IntType => s"kaitai.ProcessXOR($srcExpr, []byte{$argStr})"
          case _ => s"kaitai.ProcessXOR($srcExpr, $argStr)"
        }
        translator.returnRes = None
        xorValueStr
      case ProcessZlib =>
        translator.returnRes = Some("err")
        s"kaitai.UnprocessZlib($srcExpr)"
      case ProcessRotate(isLeft, rotValue) =>
        val argStr = if (inSubIOWriteBackHandler) "processRotateArg" else expression(rotValue)
        val expr = if (!isLeft) {
          argStr
        } else {
          s"8 - ($argStr)"
        }
        translator.returnRes = None
        s"kaitai.ProcessRotateLeft($srcExpr, int($expr))"
      case ProcessCustom(name, args) =>
        val namespace = name.init.mkString(".")
        val procClass = namespace +
          (if (namespace.nonEmpty) "." else "") +
          type2class(name.last)
        val procName = s"Process${idToStr(varSrc)}"
        if (!inSubIOWriteBackHandler) {
          // TODO: change this
          out.puts(s"$procName := New$procClass(${args.map(expression).mkString(", ")})")
        }
        translator.returnRes = Some("err")
        s"$procName.Encode($srcExpr)"
    }

    handleAssignment(varDest, expr, rep, isRaw = false)
  }

  override def attrUnprocessPrepareBeforeSubIOHandler(proc: ProcessExpr, varSrc: Identifier): Unit = {
    proc match {
      case ProcessXor(xorValue) =>
        val dataType = translator.detectType(xorValue)
        out.puts(s"var processXorArg uint8 = ${expression(xorValue)}")
      case ProcessRotate(_, rotValue) =>
        val dataType = translator.detectType(rotValue)
        out.puts(s"processRotateArg := ${expression(rotValue)}")
      case ProcessZlib => // no process arguments
      case ProcessCustom(name, args) =>
        val namespace = name.init.mkString(".")
        val procClass = namespace +
          (if (namespace.nonEmpty) "." else "") +
          type2class(name.last)
        val procName = s"Process${idToStr(varSrc)}"
        out.puts(s"$procName := New$procClass(${args.map(expression).mkString(", ")})")
    }
  }

  override def condIfIsEofHeader(io: String, wantedIsEof: Boolean): Unit = {
    val eofExpr = s"isEOF, err := $io.EOF()"
    val eofVal = "isEOF"
    val ifExpr = if (!wantedIsEof) {
      s"$eofVal"
    } else {
      s"!$eofVal"
    }

    out.puts(eofExpr)
    translator.outAddErrCheck()
    out.puts(s"if $ifExpr {")
    firstPos2InScopeHandler = true
    out.inc
  }

  override def condIfIsEofFooter: Unit = universalFooter

  override def attrBasicCheck(checkExpr: Ast.expr, actual: Ast.expr, expected: Ast.expr, msg: String): Unit = {
    val msgStr = expression(Ast.expr.Str(msg))

    out.puts(s"if ${expression(checkExpr)} {")
    out.inc

    out.puts(s"return kaitai.NewConsistencyError($msgStr, ${expression(actual)}, ${expression(expected)})")
    out.dec
    out.puts("}")
  }

  override def attrIsEofCheck(io: String, expectedIsEof: Boolean, msg: String): Unit = {
    val msgStr = expression(Ast.expr.Str(msg))

    val eofExpr = s"isEOF, err := $io.EOF()"
    val eofVal = "isEOF"
    val ifExpr = if (expectedIsEof) {
      s"!$eofVal"
    } else {
      s"$eofVal"
    }

    out.puts(eofExpr)
    translator.outAddErrCheck()
    out.puts(s"if $ifExpr {")
    out.inc
    out.puts(s"return kaitai.NewConsistencyError($msgStr, ${exprIORemainingSize(io)}, 0)")
    out.dec
    out.puts("}")
  }

  override def attrObjectsEqualCheck(actual: Ast.expr, expected: Ast.expr, msg: String): Unit = {
    importList.add("reflect")

    var changedExpr = actual
    var tmpVarName = ""
    val msgStr = expression(Ast.expr.Str(msg))
    if (inSwitchCaseHandler) {
      val (changedActual, tmpName) = translator.interfaceTypeOfSwitchCaseInExpr(actual, None, (dt) => {
        kaitaiType2NativeType(dt)
      })
      changedExpr = changedActual
      tmpVarName = tmpName
    }

    if (tmpVarName != "") {
      tmpVarName = expression(actual).replace(expression(changedExpr), tmpVarName)
    } else {
      tmpVarName = expression(actual)
    }

    out.puts(s"if !reflect.DeepEqual($tmpVarName, ${expression(expected)}) {")
    out.inc
    out.puts(s"return kaitai.NewConsistencyError($msgStr, $tmpVarName, ${expression(expected)})")
    out.dec
    out.puts("}")
  }

  override def attrParentParamCheck(actualParentExpr: Ast.expr, ut: UserType, shouldDependOnIo: Option[Boolean], msg: String): Unit = {
    if (ut.isOpaque)
      return
    val (expectedParent, dependsOnIo) = ut.forcedParent match {
      case Some(USER_TYPE_NO_PARENT) => ("nil", false)
      case Some(fp) =>
        (expression(fp), userExprDependsOnIo(fp))
      case None => ("this", false)
    }
    if (shouldDependOnIo.map(shouldDepend => dependsOnIo != shouldDepend).getOrElse(false))
      return

    var changedExpr = actualParentExpr
    var tmpVarName = ""
    val msgStr = expression(Ast.expr.Str(msg))
    if (inSwitchCaseHandler) {
      val (changedActual, tmpName) = translator.interfaceTypeOfSwitchCaseInExpr(actualParentExpr, None, (dt) => {
        kaitaiType2NativeType(dt)
      })
      changedExpr = changedActual
      tmpVarName = tmpName
    }

    if (tmpVarName != "") {
      tmpVarName = expression(actualParentExpr).replace(expression(changedExpr), tmpVarName)
    } else {
      tmpVarName = expression(actualParentExpr)
    }

    out.puts(s"if !reflect.DeepEqual($tmpVarName, $expectedParent) {")
    out.inc
    out.puts(s"return kaitai.NewConsistencyError($msgStr, $tmpVarName, $expectedParent)")
    out.dec
    out.puts("}")
  }

  override def attrBytesTypeParse(
    id: Identifier,
    dataType: BytesType,
    io: String,
    rep: RepeatSpec,
    isRaw: Boolean
  ): Unit = {
    val rawId = dataType.process match {
      case None => id
      case Some(_) => RawIdentifier(id)
    }
    val expr = parseExprBytes(translator.outVarCheckRes(parseExpr(dataType, io, None)), dataType)
    handleAssignment(rawId, expr, rep, isRaw)
    dataType.process.foreach((proc) => attrProcess(proc, rawId, id, rep))
  }

  def kstructNameFull: String = {
    kstructName.format((config.autoRead, config.readWrite) match{
      case (_, true) => ""
      case (_, false) => ""
    })
  }

  def kaitaiType2NativeType(attrType: DataType): String = {
    attrType match {
      case Int1Type(false) => "uint8"
      case IntMultiType(false, Width2, _) => "uint16"
      case IntMultiType(false, Width4, _) => "uint32"
      case IntMultiType(false, Width8, _) => "uint64"

      case Int1Type(true) => "int8"
      case IntMultiType(true, Width2, _) => "int16"
      case IntMultiType(true, Width4, _) => "int32"
      case IntMultiType(true, Width8, _) => "int64"

      case FloatMultiType(Width4, _) => "float32"
      case FloatMultiType(Width8, _) => "float64"

      case BitsType(_, _) => "uint64"

      case _: BooleanType => "bool"
      case CalcIntType => "int"
      case CalcFloatType => "float64"

      case _: StrType => "string"
      case _: BytesType => "[]byte"

      case AnyType => {
        "interface{}"
      }
      case KaitaiStructType | CalcKaitaiStructType(_) => "*" + kstructNameFull
      case KaitaiStreamType | OwnedKaitaiStreamType => "*" + kstreamName

      case t: UserType => "*" + types2class(t.classSpec match {
        case Some(cs) => cs.name
        case None => t.name
      })
      case t: EnumType => types2class(t.enumSpec.get.name)

      case at: ArrayType => s"[]${kaitaiType2NativeType(at.elType)}"

      case st: SwitchType => kaitaiType2NativeType(st.combinedType)
    }
  }
}

object GoCompiler extends LanguageCompilerStatic
  with UpperCamelCaseClasses
  with StreamStructNames
  with ExceptionNames {

  override def getCompiler(
    tp: ClassTypeProvider,
    config: RuntimeConfig
  ): LanguageCompiler = new GoCompiler(tp, config)

  def idToStr(id: Identifier): String =
    id match {
      case SpecialIdentifier(name) => name
      case NamedIdentifier(name) => Utils.upperCamelCase(name)
      case NumberedIdentifier(idx) => s"_${NumberedIdentifier.TEMPLATE}$idx"
      case InstanceIdentifier(name) => Utils.lowerCamelCase(name)
      case RawIdentifier(innerId) => s"_raw_${idToStr(innerId)}"
      case IoStorageIdentifier(innerId) => s"_io_${idToStr(innerId)}"
      case OuterSizeIdentifier(innerId) => s"${idToStr(innerId)}_OuterSize"
      case InnerSizeIdentifier(innerId) => s"${idToStr(innerId)}_InnerSize"
    }

  def publicMemberName(id: Identifier): String =
    id match {
      case IoIdentifier => "_IO"
      case RootIdentifier => "_Root"
      case ParentIdentifier => "_Parent"
      case InstanceIdentifier(name) => Utils.upperCamelCase(name)
      case _ => idToStr(id)
    }

  /**
    * Determine Go data type corresponding to a KS data type.
    *
    * @param attrType KS data type
    * @return Go data type
    */

  def types2class(names: List[String]): String = names.map(x => type2class(x)).mkString("_")

  def enumToStr(enumTypeAbs: List[String]): String = {
    val enumName = enumTypeAbs.last
    val enumClass: List[String] = enumTypeAbs.dropRight(1)
    enumToStr(enumClass, enumName)
  }

  def enumToStr(typeName: List[String], enumName: String): String =
    types2class(typeName) + "__" + type2class(enumName)

  override def kstreamName: String = "kaitai.Stream"
  override def kstructName: String = "kaitai.%sStream"
  override def ksErrorName(err: KSError): String = err match {
    case ConversionError => "strconv.NumError"
    case _ => s"kaitai.${err.name}"
  }
}
